import java.applet.Applet;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.ListIterator;
import java.awt.event.ActionEvent;
import javax.swing.Timer;

public class ColorfulCellularAutomaton extends Applet implements ActionListener, MouseListener, MouseMotionListener, ComponentListener, KeyListener{	
	double delayInSeconds = .2;
	int cellWidth = 15, savedEvolutions = 4, min = 2, max = 3, birthVal = 3, vCells, hCells;
	boolean cellsInput = true, drawGrid = false, drawPulsar = false;
	ArrayList<EvolutionState> states = new ArrayList<EvolutionState>();
	Color cellColor = Cell.colors.get(0), bgColor = new HSLColor(cellColor).getComplementary();
	EvolutionState currentState, newState;
	Timer timer;
	ListIterator<Color> colorIterator = Cell.colors.listIterator();
	
	//timer and other fun variables
	@Override
	public void init() {
		addMouseListener(this);
		addMouseMotionListener(this);
		addComponentListener(this);
		addKeyListener(this);
		vCells = getHeight() / cellWidth;
		hCells = getWidth() / cellWidth;
		currentState = new EvolutionState(vCells, hCells);
		newState = new EvolutionState(vCells, hCells);
	    timer = new Timer((int) (delayInSeconds * 1000), this);
	}
	
	public void actionPerformed(ActionEvent e){
		runLife();
	}
	
	@Override
	public void mouseClicked(MouseEvent click) {	
		cellsInput = true;
		renderCell(click);
	}
	
	
	@Override
	public void mouseDragged(MouseEvent click) {	
		cellsInput = true;
		renderCell(click);
	}
	
	//draws cell in grid configuration
	public void renderCell(MouseEvent click){
		int inputX = click.getX(), inputY = click.getY();
		//match input coordinate to corresponding x,y value in upper left corner used to draw cell
		inputSearch: 
		for(int x = 0; x <= getWidth() - cellWidth; x += cellWidth){
		for(int y = 0; y <= getHeight() - cellWidth; y += cellWidth){
			if( (inputX >= x && inputX < x + cellWidth) && (inputY >= y && inputY < y + cellWidth) ){
				if(drawPulsar){
					int yMax = 4, xMax = 4;
					int width = getWidth() - (getWidth() % cellWidth);
					int height = getHeight() - (getHeight() % cellWidth);
					while(height - (cellWidth * yMax) <= inputY) yMax--;
					while(width - (cellWidth * xMax) <= inputX) xMax--;
					for(int i = 0; i <= yMax; i++){
						currentState.addCell(new Cell(x, y + i * cellWidth));
						if(xMax == 4) currentState.addCell(new Cell(x + 4 * cellWidth, y + i * cellWidth));
					}
					if(xMax >= 2) currentState.addCell(new Cell(x + 2 * cellWidth, y));
					if(yMax == 4 && xMax >= 2) currentState.addCell(new Cell(x + 2 * cellWidth, y + 4 * cellWidth));
				}else currentState.addCell(new Cell(x, y));
				repaint();
				break inputSearch;
			}
		}
		}
	}
	
	@Override
	public void paint(Graphics g){
		g.setColor(bgColor);
		g.fillRect(0,0,getWidth(),getHeight());
		if(cellsInput){ drawInputCells(g); }
		else if(!cellsInput){ drawAllCells(g); }
		if(drawGrid){
			g.setColor(Color.gray);
			for(int x = 0; x < getWidth() - cellWidth; x += cellWidth){
			for(int y = 0; y < getHeight() - cellWidth; y += cellWidth){
				g.drawRect(x, y, cellWidth, cellWidth);
			}
			}
		}
	}

	//paints button and cells in current state
	public void drawInputCells(Graphics g){
		g.setColor(cellColor);
		for(Cell cell: currentState.getAllCells()) g.fillRect(cell.getX(), cell.getY(), cellWidth, cellWidth);
		drawAllCells(g);	
	}
	
	//draws user input cells and previous states if existing
	public void drawAllCells(Graphics g){
		Color fade = cellColor;
		int dR = cellColor.getRed() / (savedEvolutions + 2);
		int dG = cellColor.getGreen() / (savedEvolutions + 2);
		int dB = cellColor.getBlue() / (savedEvolutions + 2);
		for(int state = 0; state < states.size(); state++){
			if(state != 0) fade = new Color(fade.getRed() - dR, fade.getGreen() - dG, fade.getBlue() - dB); //lighter to darker
			g.setColor(fade);
			for(Cell cell: states.get(state).getAllCells()) g.fillRect(cell.getX(), cell.getY(), cellWidth, cellWidth);
		}
	}
	
	Image boi;
	Graphics bog;
	
	//buffering http://bit.ly/2kvDOks
	@Override
	public final void update(Graphics g) {
		boi = createImage(getWidth(), getHeight());
		bog = boi.getGraphics();
		bog.setColor(getBackground());
		bog.fillRect(0, 0, getWidth(), getHeight());
		bog.setColor(getForeground());
		paint(bog);
		g.drawImage(boi, 0, 0, this);
	}
	
	//repaints new iteration, following rules for deaths and births
	public void runLife(){
		if(states.size() >= savedEvolutions) states.remove(0); //saves fixed # of previous automata states
		states.add(currentState.clone());
		newState = currentState.clone(); //build new state off previous
		
		//kill if surrounded by fewer than pop min, greater than max, birth if surrounded by reproduction amount
		for(int r = 0; r < vCells; r++){
		for(int c = 0; c < hCells; c++){
			int neighbors = checkLegalCells(r, c);
			if((neighbors < min || neighbors > max) && currentState.getCell(r, c) != null) newState.removeCell(currentState.getCell(r, c));
			if(neighbors == birthVal) newState.addCell(new Cell(c * cellWidth, r * cellWidth));
		}
		}
		
		currentState = newState.clone(); //replace current state with new
		repaint();
	}
	
	//determines which cells to check depending on location of cell relative to number of cells in x,y direction
	public int checkLegalCells(int r, int c){
		//determine position in array
		boolean isTop    = (r == 0); 
		boolean isBottom = (r == vCells - 1);
		boolean isLeft   = (c == 0);
		boolean isRight  = (c == hCells - 1);
		
		//wrap values around AKA nifty toroidal action!
		int top    = (isTop)?    vCells - 1 : r-1;
		int bottom = (isBottom)? 0          : r+1;
		int left   = (isLeft)?   hCells - 1 : c-1;
		int right  = (isRight)?  0          : c+1;
		
		//create neighbors based on the left right top and bottom values found
		int[][] neighbors = new int[][]{
				{top,    left},{top,    c},{top,    right},
				{r,      left}            ,{r,      right},
				{bottom, left},{bottom, c},{bottom, right}};
		
		int adjacentCells = 0;	
		for(int i=0;i<8;i++) if(currentState.getCell(neighbors[i][0],neighbors[i][1]) != null) adjacentCells++; //add all the neighbors together
		return adjacentCells;
	}
	
	//only draw cells within applet size
	@Override
	public void componentResized(ComponentEvent e) {
		timer.stop();
		vCells = getHeight() / cellWidth;
		hCells = getWidth() / cellWidth;
		currentState.sizeChange(vCells, hCells);
		newState.sizeChange(vCells, hCells);
	}
	
	@Override
	public void keyPressed(KeyEvent e) { 
		switch(e.getKeyCode()){
			case KeyEvent.VK_SPACE:
				if(cellsInput) cellsInput = false;
				if(!timer.isRunning()) timer.start();
				else timer.stop();
				break;
			case KeyEvent.VK_RIGHT:
				timer.stop();
				if(delayInSeconds > .05) delayInSeconds -= .025;
				timer = new Timer((int) (delayInSeconds * 1000), this);
				timer.start();
				break;
			case KeyEvent.VK_LEFT:
				timer.stop();
				delayInSeconds += .025; 
				timer = new Timer((int) (delayInSeconds * 1000), this);
				timer.start();
				break;
			case KeyEvent.VK_UP:
				if (colorIterator.hasPrevious()){
					cellColor = colorIterator.previous();
					bgColor = new HSLColor(cellColor).getComplementary();
					repaint();
				}
				break;
			case KeyEvent.VK_DOWN:
				if (colorIterator.hasNext()){
					cellColor = colorIterator.next();
					bgColor = new HSLColor(cellColor).getComplementary();
					repaint();
				}
				break;
			case KeyEvent.VK_G:
				drawGrid = !drawGrid;
				repaint();
				break;
			case KeyEvent.VK_P:
				drawPulsar = !drawPulsar;
				break;
			case KeyEvent.VK_B:
				int initX = 8 * cellWidth;
				int initY = 14 * cellWidth;
				int pulsarWidthFromInit = cellWidth * 10;
				for(int shift = 0; shift <= 9 * cellWidth; shift += 9 * cellWidth){
					for(int x = initX + (shift); x < getWidth() - pulsarWidthFromInit; x += (cellWidth * 18)){
					for(int y = initY + (2 * shift); y < getHeight() - pulsarWidthFromInit; y += 2 * (cellWidth * 18)){
						for(int i = 0; i <= 4; i++){
							currentState.addCell(new Cell(x, y + i * cellWidth));
							currentState.addCell(new Cell(x + 4 * cellWidth, y + i * cellWidth));
						}
						currentState.addCell(new Cell(x + 2 * cellWidth, y));
						currentState.addCell(new Cell(x + 2 * cellWidth, y + 4 * cellWidth));
					}
					}
				}
				repaint();
				break;
			default:
				System.out.println("Ayy lmao");
		}
	}
	
	public void componentShown(ComponentEvent e){ 
		System.out.println("Hey, that's pretty good");
	}
	
	//ignored inherited methods...
	
	public void mouseEntered(MouseEvent e) { } public void mouseExited(MouseEvent e) { } public void mousePressed(MouseEvent e) { } 
	public void mouseReleased(MouseEvent e) { } public void mouseMoved(MouseEvent e) {} public void componentHidden(ComponentEvent e) { }
	public void componentMoved(ComponentEvent e) { } public void keyReleased(KeyEvent e) { } public void keyTyped(KeyEvent e) { }
	
}

class Cell extends ColorfulCellularAutomaton{
	private static final long serialVersionUID = 1L;
	private int cellWidth = super.cellWidth;
	private int x, y, row, column;
	protected static Color rosie = Color.decode("#D0000D"), shane = Color.decode("#6FADE9"), papa = Color.decode("#9AA9A"),
			bless = Color.decode("#B77355"), goofs = Color.decode("#600F5"), and = Color.decode("#AAA5D"), gaffs = Color.decode("#6AFF5");
	protected static ArrayList<Color> colors = new ArrayList<>(Arrays.asList(rosie, shane, papa, bless, goofs, and, gaffs));
	
	//defines coordinate in terms of ints, row/column determined relative to x,y coordinate
	public Cell(int x, int y){ 
		this.x = x;
		this.y = y;
		row    = y / cellWidth;
		column = x / cellWidth;
	}
	
	public int getX(){ return x; }
	public int getY(){ return y; }
	public int getRow(){ return row; }
	public int getColumn(){ return column; }
}
